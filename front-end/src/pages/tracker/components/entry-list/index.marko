import ServerProxy from "../../../../utils/serverproxy.js";
import {niceDate, dateInPast, now} from "../../../../utils/dateutils.js";
import {emit} from "../../../../utils/events.js";

class {
    onCreate() {
        this.state = {
            data: {},
            disabled: []
        };

        this.timeEntryPopout = null;
        this.firstDate = dateInPast(30);
        this.generateReport();
    }

    generateReport() {
        ServerProxy.generateReport(this.firstDate, now(), [], [], (report) => {
            this.state.data = report;
            this.state.data.days = this.state.data.days.reverse();
            this.setStateDirty("data");
        });
    }

    refresh() {
        this.generateReport();
    }

    onMount() {
        window.onscroll = this.loadMoreData.bind(this);
        this.timeEntryPopout = this.getComponent("time-entry-popout");
    }

    async loadMoreData(event) {
        if (document.documentElement.scrollTop > document.getElementById("entries-wrapper").clientHeight - 350 && !this.state.loadingData) {
            this.state.loadingData = true;
            let last = this.firstDate - (1000 * 60 * 60 * 24);
            this.firstDate -= (1000 * 60 * 60 * 24 * 7);
            
            let response = await utils.post("/api/report", {
                start: this.firstDate, //Start date
                end: last, //End date
                projects: [], //A list of projectIDs to include in the report. Empty to include all projects.
                tasks: [] //A list of taskIDs to include in the report. Empty to include all tasks.
            });
            if(response.success) {
                console.log(response.data);
                console.log("YAY");
                this.state.data.days = this.state.data.days.concat(response.data.days.reverse());
                this.state.tasklist = this.state.tasklist.concat(Object.values(response.data.tasks).map((el) => {return {search: el.name + " " + el.project.name, value: el.name, project: el.project.name, color: el.project.color, projectid: el.project._id};}));
            }
            this.setStateDirty("data");
            this.setStateDirty("tasklist");
        }
    }

    confirmDeleteEntry(entry, index, dayIndex) {
        emit("confirm", {
            title:"Delete Entry?", 
            message:"Are you sure you want to delete the entry for '" + entry.name + "' on " + new Date(entry.start).toDateString() + "? This cannot be undone.",
            actions: [
                {
                    text: "Yes",
                    icon: "check",
                    callback: ()=>{
                        this.deleteEntry(entry, index, dayIndex); 
                        this.state.disabled.push(entry._id);
                        this.setStateDirty("disabled");
                    }
                },
                {
                    text: "Cancel",
                    icon: "x",
                    callback: function() {}
                }
            ]}
        );
    }

    async deleteEntry(entry, index, dayIndex) {
        ServerProxy.deleteEntry(entry._id, ()=>{
            this.state.data.days[dayIndex].entries.splice(index, 1);
            this.setStateDirty("data");
        });
    }

    async editTimeEntry(id) {
        await this.timeEntryPopout.loadTimeEntry(id);
        this.timeEntryPopout.toggleVisibility();
    }

    async markTaskTodo(event) {
        let id = event.entry.taskid;
        let index = event.index;
        let response = await utils.post("/api/task/status", {
            userid: this.userid,
            taskid: id,
            status: "todo"
        });
        if(response.success) {
            for(let entry of this.input.entries) {
                if(entry.taskid === id) {
                    entry.status = "todo";
                }
            }
            this.state.entries = this.input.entries;
        }
    }

    async continueTask(entry) {
        this.emit("continuetask", {name: entry.task.name, project: entry.project});
    }
}

time-entry-popout key="time-entry-popout" on-saved("refresh")
ui-linear-layout vertical gutter="16px" id="entries-wrapper"
    for|day, dayIndex| of=state.data.days||[]
        if(day.entries.length > 0)
            @element
                listwidget title=niceDate(day.date) subtitle=day.hoursTracked.toFixed(2)+"hrs" items=day.entries.sort((el1, el2) => {return el2.start - el1.start;})
                    @item|{data, index}| // Data here is a timeEntry from the items list.
                        ui-linear-layout aligncenter wrap
                            @element fillspace
                                ui-text -- ${data.task.name}
                            @element
                                project project=data.project
                            @element
                                ui-date date=false milliseconds=data.start
                            @element
                                ui-date date=false milliseconds=data.end
                            @element
                                ui-time milliseconds=data.end-data.start
                            @element
                                $ let controls = [{name: "Todo", icon: "flag"}, {name: "Delete", icon: "trash"}, {name: "Edit", icon: "edit-2"}, {name: "Continue", icon: "play"}]
                                controls controls=controls on-continue("continueTask", data) on-delete("confirmDeleteEntry", data, index, dayIndex) on-edit("editTimeEntry", data._id)